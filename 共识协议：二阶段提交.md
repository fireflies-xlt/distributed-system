# 附


原文：[共识协议：二阶段提交](https://www.the-paper-trail.org/post/2008-11-27-consensus-protocols-two-phase-commit/)


相关名词的翻译
- Consensus Protocols：此处翻译成共识协议，有其他翻译为一致性协议
- 2pc & two phase commit: 二阶段提交
- coordinator：协调者
- abort：中止
- Termination: 终止
- Failures：故障
- Crashes：崩溃
- participant: 参与者
- proposal：提议

# 正文


在接下来几篇文章中，我将介绍分布式计算中最基本的概念之一 --- 共识问题，其在理论和实践社区都具有同等的重要性。共识问题是指让分布式系统的一系列节点在某些事情上达成一致——它可能是一个值、一个行动过程或一个决定。实现共识可以把分布式系统当成一个整体（single entity），每个节点都能感知到整个网络的行为，并与其保持一致。

共识的一些场景可能是：
- 决定是否向数据库提交事务
- 约定当前时间来同步时钟
- 分布式算法进入下个阶段达成一致（这是著名的复制状态机方法）
- 选举一个领导节点（leader node）去协调一些更高级的协议

听起来如此简单的问题，竟然是分布式系统理论研究了二十多年的核心。怎么会这样，在我看来，答案包括三部分。

首先，事实证明共识是一个非常复杂的问题，它可以用来描述系统模型之间不同强度的差异。正如我在FLP结果（一篇文章）强调的那样，共识可以在同步系统中解决，但在异步系统中，如果存在任何可能的故障，则没法解决。因此，问题在于两个模型之间的边界，并且很大程度上依赖于时序的假设。

其次，实现共识协议是非常难的。简单的方法未必有效，会表现出不良的行为和偶尔的执行错误。谷歌的Chubby service开发者Mike Burrows说：“只有一个共识协议，那就是Paxos”，其他所有的解决方法都是Paxos的残缺版本(broken versions of Paxos)。由Leslie Lamport构思的Paxos协议以微妙着称，但有点难以理解（尽管Lamport没必要通过对希腊议会程序的讽喻，来解决这个问题）。不管你是否相信，很明显，要找到一个好的共识协议是非常困难的。

第三，共识是一个重要问题。分布式数据库基于它实现。事实上，大多数分布式系统都是在它之上构建的。社交系统（Group membership systems）、可容错的复制状态机、数据存储——所有典型的分布式系统在某种程度上都是基于能够解决共识问题的。在某种程度上，这是因为共识与另一个重要问题 -- 原子广播，是同构的，原子广播能够可靠地将网络中的消息按整体顺序传送到所有节点。在后面的文章中将看到为什么原子广播和共识是同一问题的两个实例。

## 正式定义
对于共识如此重要的问题，理论学家首先要给它们下定义，以便更好地进行推理。在这篇文章中，我将使理论变得简单，但是我们需要了解什么构成了共识问题的实现。幸运的是，它只涉及三个属性。

我们说，一个节点，当收到它认为其他节点一致同意的决定时，其作出决策。更正式的定义，每个节点都有一个输出寄存器，一旦协议终止，其包含达成一致的值，向寄存器写值就是下决定（deciding）的行为。

节点提出一个值，用于让其他节点达成一致。节点提出的值是被预先确定的——协议不允许节点提出任何特定的值(稍后我们将看到确切的原因)。

考虑到这两个定义，我们在分布式系统中给出N个节点，当且仅当在以下条件成立，共识协议是正确的：
1. 一致性 - N个节点都作出相同的决定
2. 有效性 - 决策的值必须由N个节点的某些节点提出
3. 终止性 - 所有节点最终会下决定

一致性很容易被理解：如果没有取得一致，我们不能说真正实现共识。可以考虑弱化这一要求，只要求大多数节点达成一致，但这不会弱化问题的难度和所需的解决方案。

有效性不那么直观，但同时看起来也很明显。问题在于，无论网络实际情况如何，一致性属性只是简单实现让协议指导每个节点对一个默认值做投票。例如，不管事务存在，数据库提交协议始终投“不提交（dont't commit）”满足了一致性条件。有效性确保这些协议不会被通过检查。

终止性也是一个合理的要求，但是需要思考为什么需要终止性。有效性只是约束节点如何下决定，而不是节点是否决定。我们需要终止性，确保协议确实做了一些有用的事情，否则我们将又一次接受无意义的简单解决方案，其满足一致性和有效性。

请注意，我们至今还没有说到对故障的容忍。在参与者可能崩溃和故障的情况下，设计一个能够工作的协议是十分困难的，稍后我们将重新讨论故障带来的影响。


## 二阶段提交

共识问题的简单解决方案似乎显而易见，想想你如何解决一个现实的共识问题 -- 如果你想和三个朋友组织一场四个人的桥牌游戏，你会轮流给你的朋友打电话，提出一个游戏和时间，如果时间都OK，你需要重新打一轮电话和他们确认，但如果有人否定这个时间，你需要打给所有人，告诉他们游戏不能进行了，同时你可能也会建议新的一天去玩，然后重新开始一轮新的共识。

这是实现共识的一种很自然的方式，尽管稍微简化，省略了一些“针对人类”的优化。我们可以确定该过程中的两个步骤：
1. 联系所有的参与者，建议一个值，并且收集他们的回复
2. 如果所有参与者都同意，再次联系让他们知道，否则告诉他们有人不同意（原文：abort the consensus，中止共识）。

这个框架可能描述了最简单、最常用的共识算法，称为二阶段提交或2pc。顾名思义，2PC有两个不同的阶段。第一个提议阶段，包括向系统的每个参与者提出一个值并收集意见。第二个提交或拒绝阶段，将投票结果告诉参与者，并让他们做出行动(go ahead and decide)或者中止协议。

处理提出值称为协调者，不需要被特别的选举，只要任何节点愿意都可以充当协调者，并发出一轮2pc。

注意，这里的共识是关于是否接受协调者提出的值，而不是值本身。所以节点在实现共识算法并没有关注这个值应该是什么，而是是否接受这个值。这是一个二进制值，yes或者no，提交或者中止。参与者没有机制说：“实际上，我宁愿投票赞成X，而不是提议的y值”，如果他们想要这么做，他们必须发起一轮自己的2pc。

如上所述，在不担心任何故障的情况下，2pc能解决共识问题？一致性容易得出，当且仅当，每个节点在第一阶段对协调者提议的值做决定时，它们在第二阶段将被协调者告知那么做（第一阶段做的决定，they are told do so）。协调器向每个节点发送相同的决定，所以如果一个节点被告诉决定的值时，那么其他节点都被告知同样的值。

有效性同样满足。2PC不是简单的“提交”或“中止”，除了每个节点同意“提交”的情况外，其他情况下（协议）都会“中止”。在所有情况下，保证至少有一个节点对最终确定的值进行了投票。

最后，如果每个节点都能保证正常运行，并最终返回投票结果给协调者，协调者将投票结果传递给每个节点，那么终止性将被保证。注意，在没有任何故障的情况下，异步模型也会保证此属性：最终所有的消息会被处理，所有的响应会被发送。2PC的规范中没有循环，因此它不可能永远继续执行。

因此，2PC确实为共识提供了一个解决方案。它的优点是非常高效，对于n个节点来说，交换的消息数为3n，很难看出还有多大的提升。

然而，正如我之前强烈暗示的那样，2PC有一个美中不足之处，如果允许节点故障，甚至只要有一个节点故障，那么事情将会变得很复杂。

## 崩溃和故障
正如文章其他地方所讨论的，节点有几种崩溃的方式，最常见，它们可能崩溃后，永远无法恢复，这是分布式系统故障模型的“故障停止”。或者节点可能崩溃，过会从故障中恢复并继续执行，这是“故障恢复”模型。大多情况下，节点可能以意想不到的方式偏离协议规范，这就是“拜占庭式失败”，设计协议去解决这个问题是一个活跃的研究领域，但是相当困难。我们认为最普遍的故障模型为“故障恢复”（也可以说这也是最常见的故障模型）。

节点故障对2pc造成怎么样的影响呢？要回答这个问题，我们必须审视协议在每个阶段可以了解的状态，并考虑协调者或其中一个参与者在该状态下崩溃会发生什么。

阶段1中，协调者在发送任何消息之前崩溃，没有造成太大的影响，仅仅意味着2pc永远不会启动(因此，毫无意义地，它可以正常工作)。如果参与者在协议启动前崩溃，那么在提议消息无法到达崩溃节点之前不会发生任何糟糕的事情，因此我们可以稍后处理该故障。

现在，考虑协议发送了一部分（还没全部发送）提议消息，如果协调者在这个时候崩溃，将会有一些收到提议的节点开始一轮2PC，另外一些节点并没有意识到这个事情的发生。如果协调者长时间没有恢复，那些收到提议的节点将被阻塞，等待永远不会完成的协议结果。这意味着没有其他协议的实例能够被正确的执行，那些投了“提交”的参与者不得不对资源进行上锁。这些节点会把投票发回协调者，却没有意识到已经失败。但这不能简单地超时并中止协议，因为协调者可能重新恢复，看到他们的“提交”投票，然后开启协议的第二阶段，发送提交消息。

因此，协议将在协调者阻塞，无法进行下去。我们可以添加一些机制来处理这个问题，我们将在下面描述，但是等待一些参与者完成他们在协议的流程这个问题是2PC永远无法解决的。

我们可以做的是，一旦我们意识到它已经崩溃，就让另一个参与者接手协调者的工作，来解决这个问题。当某个节点发生超时，我们可以强制该节点充当备份协调者启动并完成协议。就像阶段一那样，这个节点可以联系其他参与者，并了解他们的投票。这要求所有节点保存2pc提交的投票，直到它们知道其他所有节点“提交”或“中止”。否则，如果所有节点都忘了提交的投票，那么当恢复节点接管协调者工作时，将没法恢复事务的状态。如果在阶段二，所有节点被告知中止或者提交的决定前协调者故障了，那么有可能只有一个节点（故障协调者本身）知道这个事务的结果。

但是，如果另一个参与者在恢复节点完成协议之前崩溃，则无法恢复协议的状态。恢复节点无法区分所有节点已经投票“提交”(voted to commit)和故障的参与者提交事务（committed）（这种情况下对于默认中止是无效的）。和除了故障的节点已经投“中止”，其他投“提交”(在这种情况下默认提交是无效的)。

同样的情况在第二阶段也广泛的适用。如果协调器在提交消息到达所有参与者之前崩溃，我们需要一个恢复节点来接管并安全地引导协议完成。

最坏的情况是，协调者本身就是参与者，自身拥有协议结果的投票权。当协调者崩溃时，同时带走一个参与者，从而让协议将一直阻塞，这仅仅是因为一个节点故障导致的。

协调器通常会将任何协议成功的结果记录在持久存储中，以便在恢复后可以回答有关事务是否被提交的查询。这样就可以对参与者定期做日志的垃圾回收：协调者可以告诉节点，没人会尝试恢复一个已提交的事务，且可以从日志中清除其存在。（也就是说，在节点崩溃后，日志将被保存，以便恢复节点的状态）。


## 结论
2PC仍然是一种非常流行的共识协议，因为它具有较低的消息复杂度（尽管在故障的情况下，如果每个节点都决定成为恢复节点，复杂度可以达到O(n^2)）。与协调者交互的客户端可以在3个消息延迟时间得到回复。这种低延迟对某些应用程序非常有吸引力。

然而，2pc在协调者故障时造成阻塞是一个严重的问题，极大地影响了可用性。如果事务可以在任何时候回滚，那么协议可以在节点超时后恢复，但如果协议必须将任何提交视为永久，故障会导致整个事情突然停止。

尽管如此，仍然有一些包含2PC的前沿研究项目。最近，最有影响的是Sinfonia (PDF)，它在SOSP 2007年获得了最佳论文奖。其在2PC之上构建了一种分布式内存，但是协调者故障时可以恢复（通过超时和干预恢复节点）。内存节点崩溃被认为是“游戏结束”的场景(但是内存节点本身可能被高度复制)。这是一篇好文章，我推荐你去读。

下一次我将介绍3PC，它以额外消息延迟作为代价，解决了2PC的阻塞问题。

